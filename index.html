<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>盖房子01</title>
	<!-- 样式 -->
	<style>
		*{
			margin: 0;
			padding: 0;
		}
		#box{
			position: relative;
			width: 600px;
			height: 500px;
			margin: 0px auto;
			border: 2px solid #999;
			overflow: hidden;
		}
		#wrap{
			position: absolute;
			width: 600px;
			bottom: 0;
		}
		#fraction{
			position: absolute;
			top: 5px;
			width: 100%;
			text-align: center;
			font-size: 50px;
			color: #333;
		}
		.row{
			position: absolute;
			overflow: hidden;
		}
		.row div{
			float: left;
			width: 20px;
			height: 20px;
			border: 1px solid #000;
			box-sizing:border-box;
			background: #ccc;
		}
	</style>
</head>
<body>
	<!-- 结构 -->
	<p id="fraction"></p>
	<div id="box">
		<div id="wrap"></div>
	</div>
	<!-- 行为 -->
	<script>
		function house(){
			// 1.获取容器wrap元素
			var wrap=document.getElementById('wrap');
			// 获取到最外层的box容器
			var box=document.getElementById('box');
			// 获取积分对象
			var fraction=document.getElementById('fraction');
			// 定义bottom变量，因为每次点击都会改变
			var bottom=0;
			// 创建一个小格子的变量
			var rowNum=20;
			// 定义一个变量用来记录每个小格子的宽度
			var pieceWidth=20;
			// 定义循环定时器时间变量
			var time=500;
			

			// 2.创建每一行小格子的方法
			function createRow(){
				// 创建div元素对象
				var row=document.createElement('div');
				// 为row对象添加类选择器名
				row.className="row";
				// 为row对象添加属性
				row.style.bottom=bottom+"px";
				// 为row设定宽度
				row.style.width=rowNum*pieceWidth+"px";

				// 为每行row添加一个方向属性，用于控制移动的左右方向
				row.direction=true;

				// 指定父级元素
				wrap.appendChild(row);

				// 循环创建row的内部小方块
				for(var i=0;i<rowNum;i++){
					var piece=document.createElement('div');
					// 指定父级元素
					row.appendChild(piece);
				}

				// 让整行开始摇摆
				function moveRow(){


					// 定义一个初始移动变量
					var rowStart=0;
					// 获取移动的最大宽度,容器可视宽度-每行的宽度
					var maxWidth=wrap.clientWidth-row.offsetWidth;
					// 循环控制当前行的移动动画
					// row.timer是为了控制每行的定时器的名字
					row.timer=setInterval(function(){
						// 如果条件为真
						if (row.direction) {
							// 那么让rowStart每次移动20像素
							rowStart+=20;
							// 再判段，如果rowStart已经大于等于最大宽度200
							if (rowStart>=maxWidth) {
								// 那么让方向的值为假
								row.direction=false;
							}
						}else{//否则让rowStart每次减20像素
							rowStart-=20;
							// 再判断，如果rowStart的值已经小于等于0
							if (rowStart<=0) {
								// 那么让方向的值为真
								row.direction=true;
							}
						}
						
						// 改变当前行的左定位
						row.style.left=rowStart+"px";
					},time);
				}
				moveRow();
				// 将当前的row行作为返回值
				return row;
			}
			createRow();

			// 盖房子02的代码
			// 为wrap添加点击事件
			box.onclick=function(){
				fraction.innerHTML++;
				// 点击一次就让当前的定时器的时间减少50，保证越来越快
				time-=50;
				// 以防止定时器过少，导致动画减少
				if (time<=100) {
					time=100;
				}

				// 调用删除removeRow
				removeRow();


				// 让每次点击,bottom+20
				bottom+=20;

				if (bottom>200) {
					wrap.style.bottom=-(bottom-200)+"px";
				}

				// 创建新的row元素
				var row=createRow();
				// 获取当前最新一行的上一行兄弟节点元素
				var prevRow=row.previousElementSibling;
				// 判断上一层元素是否为空，如果不为空
				if (prevRow!=null) {
					// 那么清除上一层元素的定时器
					clearInterval(prevRow.timer);
				}
				
			}

			// 盖房子03的代码
			// 创建移出小格子的方法
			function removeRow(){
				// 获取当前移动的行
				var nowRow=wrap.lastElementChild;
				// 获取当前移动行的上一行
				var nowPreRow=nowRow.previousElementSibling;

				// 	如果当前行的上一行存在
				if (nowPreRow) {
					// 计算移动的行与上一行多出的小格子
					var different=nowRow.offsetLeft-nowPreRow.offsetLeft;
					console.log(different);
				}else{//否则偏差为0
					var different=0;
				}
				// 得出需要消除的小格子的个数
				var removeNum=different/pieceWidth
				// 获得小方块的总块数=总块数(20)-多出的块数的绝对值(删除的块数)
				rowNum=rowNum-Math.abs(removeNum);

				// 游戏结束
				if (rowNum<=0) {
					// 游戏结束时，清除定时器
					clearInterval(nowRow.timer);
					nowRow.timer=null;
					// 提醒用户
					alert("游戏结束");
					box.onclick=null;
				}

				// 获取当前对象下的所有的子元素（所有的小格子）
				var pieceNum=nowRow.children;
				// 判断如果大于0，那么干掉右边的块数
				if (removeNum>0) {
					// 循环获取删除小格子
					for(var i=0;i<removeNum;i++){
						// removeObj创建要删除的格子对象
						// pieceNum.length:消除前格子的个数
						// i:要删除的个数
						// -1:因为下标从0开始。
						var removeObj=nowRow.children[pieceNum.length-i-1];
					}
					setTimeout(function(){
						// 循环删除
						for(var i=0;i<removeNum;i++){
							nowRow.removeChild(nowRow.lastElementChild);
						}
					},1000);
				}else{
					removeNum*=-1;
					// 当移动行小于0的时候，说明是向左侧移动
					for(var i=0;i<removeNum;i++){
						// 从当前行的最前头删除元素
						nowRow.removeChild(nowRow.firstElementChild);
					}
					// 重新设置移动的left的值
					nowRow.style.left=nowRow.offsetLeft+removeNum*pieceWidth+"px";
				}
			}
		}
		house();
	</script>









</body>
</html>